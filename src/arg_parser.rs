use crate::rules::Rule;
use clap::Parser;
use serde::Deserialize;
use std::collections::HashSet;
use std::fs;
use std::path::{Path, PathBuf};

/// Parsed command-line arguments.
///
/// This structure is generated by `clap` and controls input source,
/// configuration file location, and matching behavior.
#[derive(Debug, Parser)]
#[command(
    name = "highlite",
    about = "Highlight lines from stdin or a file",
    long_about = "Highlight lines from stdin or a file using a YAML configuration.\n\
                      Reads from stdin if no file is provided."
)]
pub struct CliArgs {
    /// Force to perform case-insensitive matching.
    /// This overrides `ignore_case` settings in the configuration file.
    #[arg(short, long)]
    pub ignore_case: bool,

    /// Path to the input file.
    /// If omitted, input is read from standard input.
    #[arg(short, long, help = "Path to the input file (defaults to stdin)")]
    pub file: Option<PathBuf>,

    /// Path to the YAML configuration file.
    /// This option is required.
    #[arg(short, long, help = "Path to the YAML config file (optional)")]
    pub config: Option<PathBuf>,

    /// Follow system journal logs in real-time (`journalctl -f`).
    #[arg(long, help = "Follow system journal logs (journalctl -f)")]
    pub follow_journal: bool,

    /// Follow a specific log file in real-time (`tail -f <PATH>`).
    #[arg(long, help = "Follow a log file (tail -f <PATH>)")]
    pub follow_file: Option<PathBuf>,

    /// Use a built-in preset (like `logs`, `json`, or `cpp`).
    /// Ignored if `--config` is provided.
    #[arg(short, long, help = "Use built-in preset (optional)")]
    pub preset: Option<String>,

}

/// Deserialized representation of a configuration file.
///
/// A configuration file may include additional configuration files
/// and/or define a list of highlighting rules.
#[derive(Debug, Deserialize)]
pub(crate) struct FileConfig {
    /// Paths to other configuration files to include.
    pub(crate) include: Option<Vec<String>>,

    /// Highlighting rules defined in this file.
    pub(crate) rules: Option<Vec<Rule>>,
}

/// Loads highlighting rules from a YAML configuration file.
///
/// This function resolves `include` directives recursively and prevents
/// duplicate loading of the same file.
///
/// # Examples
///
/// ```no_run
/// use highlite::arg_parser::load_rules_from_file;
///
/// let rules = load_rules_from_file("rules.yaml").unwrap();
/// println!("Loaded {} rules", rules.len());
/// ```
///
/// # Errors
///
/// Returns an error if a file cannot be read, parsed, or resolved.
pub fn load_rules_from_file<P: AsRef<Path>>(path: P) -> anyhow::Result<Vec<Rule>> {
    let mut loaded_files = HashSet::new();
    load_rules_recursive(path.as_ref(), &mut loaded_files)
}

/// Recursively loads highlighting rules from a configuration file.
///
/// This function parses the given YAML configuration file, resolves any
/// `include` directives relative to the file's parent directory, and
/// accumulates all discovered rules into a single list.
///
/// To prevent infinite recursion and duplicate rule loading, each
/// configuration file is canonicalized and tracked in the `loaded` set.
/// Files that have already been processed are silently skipped.
///
/// # Parameters
///
/// * `path` - Path to the configuration file to load.
/// * `loaded` - A set of canonicalized file paths that have already been
///   processed.
///
/// # Errors
///
/// Returns an error if:
///
/// * The file cannot be canonicalized
/// * The file cannot be read
/// * The YAML content cannot be parsed
/// * An included file cannot be resolved or loaded
fn load_rules_recursive(
    path: &Path,
    loaded: &mut HashSet<String>,
) -> anyhow::Result<Vec<Rule>> {
    let canonical_path = fs::canonicalize(path)?.to_string_lossy().to_string();

    if !loaded.insert(canonical_path) {
        return Ok(vec![]);
    }

    let text = fs::read_to_string(path)?;
    let file_config: FileConfig = serde_yml::from_str(&text)?;
    let mut all_rules = Vec::new();

    if let Some(includes) = file_config.include {
        let parent_dir = path.parent().unwrap_or_else(|| Path::new("."));
        for inc_path in includes {
            let full_path = parent_dir.join(inc_path);
            all_rules.append(&mut load_rules_recursive(&full_path, loaded)?);
        }
    }

    if let Some(current_rules) = file_config.rules {
        all_rules.extend(current_rules);
    }

    Ok(all_rules)
}