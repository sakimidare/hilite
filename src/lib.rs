//! `highlite` — A configurable syntax-highlighting filter for terminal output.
//!
//! `highlite` reads text from a file or standard input and highlights matching
//! keywords or regular expressions according to a user-provided YAML
//! configuration file.
//!
//! ## Features
//!
//! - Highlight fixed keywords or regular expressions
//! - Support for preset ANSI colors and 24-bit RGB colors
//! - Read from files or `stdin`
//! - Efficient multi-pattern matching using a single compiled regex
//!
//! ## Example
//!
//! ```bash
//! highlite --config rules.yaml --file file.txt
//!
//! cat file.txt | highlite --config rules.yaml
//! ```

use anyhow::Context;
use regex::{Regex, RegexBuilder};
use std::fs;
use std::io::{BufRead, BufReader, BufWriter, IsTerminal, Write};


/// Types related to highlighting rules and color definitions.
///
/// This module defines the data structures used to describe how text
/// should be highlighted, including keywords, matching behavior, and
/// ANSI color output.
pub mod rules {
    use serde::Deserialize;

    /// A single highlighting rule.
    ///
    /// Each rule defines a keyword or pattern to match, along with the color
    /// used to render matched text.
    ///
    /// Rules are typically loaded from a YAML configuration file.
    /// # Examples
    ///
    /// ```yaml
    /// rules:
    ///   - keyword: "ERROR"
    ///     color: { type: "Red" }
    ///     is_regex: false
    ///   - keyword: "//.*|/\\*.*\\*/"
    ///     is_regex: true
    ///     color: { r: 106, g: 153, b: 85 }
    /// ```
    #[derive(Debug, Clone, Deserialize)]
    pub struct Rule {
        pub keyword: String,
        pub color: Color,
        #[serde(default)]
        pub is_regex: bool,
    }

    /// A predefined ANSI color.
    ///
    /// These colors correspond to standard 8-color ANSI escape sequences.
    #[derive(Debug, Copy, Clone, Deserialize)]
    #[serde(tag = "type", rename_all = "PascalCase", content = "value")]
    pub enum PresetColor {
        Red,
        Yellow,
        Blue,
        Green,
        Cyan,
        Magenta,
    }

    /// A color specification for highlighted text.
    ///
    /// Colors can be specified either as a predefined ANSI color
    /// or as a 24-bit RGB value.
    ///
    /// # Examples
    ///
    /// Using a preset ANSI color:
    ///
    /// ```yaml
    /// color: { type: Red }
    /// ```
    ///
    /// Using a 24-bit RGB value:
    /// ```yaml
    /// color: { r: 181, g: 206, b: 168 }
    /// ```
    #[derive(Debug, Copy, Clone, Deserialize)]
    #[serde(untagged)]
    pub enum Color {
        Preset(PresetColor),
        RGB { r: u8, g: u8, b: u8 },
    }

    impl Color {
        /// Converts this color into an ANSI escape sequence.
        ///
        /// The returned string enables the color when written to a terminal.
        /// Callers are responsible for resetting formatting (e.g. with `\x1b[0m`)
        /// after use.
        pub fn to_ansi(&self) -> String {
            match self {
                Color::Preset(p) => match p {
                    PresetColor::Red => "\x1b[31m".to_string(),
                    PresetColor::Yellow => "\x1b[33m".to_string(),
                    PresetColor::Blue => "\x1b[34m".to_string(),
                    PresetColor::Green => "\x1b[32m".to_string(),
                    PresetColor::Cyan => "\x1b[36m".to_string(),
                    PresetColor::Magenta => "\x1b[35m".to_string(),
                },
                Color::RGB { r, g, b } => format!("\x1b[38;2;{};{};{}m", r, g, b),
            }
        }
    }
}

/// Command-line argument parsing and configuration loading.
///
/// This module defines CLI options and functions for loading and resolving
/// highlighting rules from YAML configuration files, including recursive
/// `include` directives.
pub mod arg_parser {
    use crate::rules::Rule;
    use clap::Parser;
    use serde::Deserialize;
    use std::collections::HashSet;
    use std::fs;
    use std::path::{Path, PathBuf};

    /// Parsed command-line arguments.
    ///
    /// This structure is generated by `clap` and controls input source,
    /// configuration file location, and matching behavior.
    ///
    /// # Examples
    ///
    /// ```no_run
    /// use highlite::arg_parser::CliArgs;
    ///
    /// let args = CliArgs {
    ///     ignore_case: true,
    ///     file: None,
    ///     config: Some("rules.yaml".into()),
    /// };
    /// ```
    #[derive(Debug, Parser)]
    #[command(name = "highlite", about = "Highlight lines from stdin or a file")]
    pub struct CliArgs {
        /// Perform case-insensitive matching.
        #[arg(short, long)]
        pub ignore_case: bool,

        /// Path to the input file.
        ///
        /// If omitted, input is read from standard input.
        #[arg(short, long, help = "Path to the input file (defaults to stdin)")]
        pub file: Option<PathBuf>,

        /// Path to the YAML configuration file.
        ///
        /// This option is required.
        #[arg(short, long, help = "Path to the YAML config file (required)")]
        pub config: Option<PathBuf>,
    }

    /// Deserialized representation of a configuration file.
    ///
    /// A configuration file may include additional configuration files
    /// and/or define a list of highlighting rules.
    #[derive(Debug, Deserialize)]
    pub struct FileConfig {
        /// Paths to other configuration files to include.
        pub include: Option<Vec<String>>,

        /// Highlighting rules defined in this file.
        pub rules: Option<Vec<Rule>>,
    }

    /// Loads highlighting rules from a YAML configuration file.
    ///
    /// This function resolves `include` directives recursively and prevents
    /// duplicate loading of the same file.
    ///
    /// # Examples
    ///
    /// ```no_run
    /// use highlite::arg_parser::load_rules_from_file;
    ///
    /// let rules = load_rules_from_file("rules.yaml").unwrap();
    /// println!("Loaded {} rules", rules.len());
    /// ```
    ///
    /// # Errors
    ///
    /// Returns an error if a file cannot be read, parsed, or resolved.
    pub fn load_rules_from_file<P: AsRef<Path>>(path: P) -> anyhow::Result<Vec<Rule>> {
        let mut loaded_files = HashSet::new();
        load_rules_recursive(path.as_ref(), &mut loaded_files)
    }

    /// Recursively loads highlighting rules from a configuration file.
    ///
    /// This function parses the given YAML configuration file, resolves any
    /// `include` directives relative to the file's parent directory, and
    /// accumulates all discovered rules into a single list.
    ///
    /// To prevent infinite recursion and duplicate rule loading, each
    /// configuration file is canonicalized and tracked in the `loaded` set.
    /// Files that have already been processed are silently skipped.
    ///
    /// # Parameters
    ///
    /// * `path` - Path to the configuration file to load.
    /// * `loaded` - A set of canonicalized file paths that have already been
    ///   processed.
    ///
    /// # Errors
    ///
    /// Returns an error if:
    ///
    /// * The file cannot be canonicalized
    /// * The file cannot be read
    /// * The YAML content cannot be parsed
    /// * An included file cannot be resolved or loaded
    fn load_rules_recursive(
        path: &Path,
        loaded: &mut HashSet<String>,
    ) -> anyhow::Result<Vec<Rule>> {
        let canonical_path = fs::canonicalize(path)?.to_string_lossy().to_string();

        if !loaded.insert(canonical_path) {
            return Ok(vec![]);
        }

        let text = fs::read_to_string(path)?;
        let file_config: FileConfig = serde_yml::from_str(&text)?;
        let mut all_rules = Vec::new();

        if let Some(includes) = file_config.include {
            let parent_dir = path.parent().unwrap_or_else(|| Path::new("."));
            for inc_path in includes {
                let full_path = parent_dir.join(inc_path);
                all_rules.append(&mut load_rules_recursive(&full_path, loaded)?);
            }
        }

        if let Some(current_rules) = file_config.rules {
            all_rules.extend(current_rules);
        }

        Ok(all_rules)
    }
}

/// High-performance text highlighting engine.
///
/// This module compiles all rules into a single regular expression and
/// efficiently renders matched text with ANSI color sequences.
///
/// # Examples
///
/// ```rust
/// use highlite::highlight::HighlightingEngine;
/// use highlite::rules::{Rule, Color, PresetColor};
///
/// let rules = vec![
///     Rule {
///         keyword: "error".into(),
///         color: Color::Preset(PresetColor::Red),
///         is_regex: false,
///     },
/// ];
///
/// let engine = HighlightingEngine::new(&rules, true).unwrap();
///
/// let mut out = String::new();
/// engine.render_line("An error occurred\n", &mut out);
///
/// assert!(out.contains("\x1b[31m"));
/// ```
pub mod highlight {
    /// A compiled highlighting engine.
    ///
    /// Internally, all rules are combined into a single regular expression
    /// using named capture groups to efficiently determine which rule
    /// produced a match.
    pub struct HighlightingEngine {
        regex: crate::Regex,
        ansi_colors: Vec<String>,
    }

    impl HighlightingEngine {
        /// Creates a new highlighting engine from a list of rules.
        ///
        /// All rules are compiled into a single regular expression to minimize
        /// matching overhead.
        ///
        /// # Errors
        ///
        /// Returns an error if the combined regular expression fails to compile.
        pub fn new(rules: &[crate::rules::Rule], ignore_case: bool) -> anyhow::Result<Self> {
            let mut patterns = Vec::with_capacity(rules.len());
            let mut ansi_colors = Vec::with_capacity(rules.len());

            for (i, rule) in rules.iter().enumerate() {
                let pat = if rule.is_regex {
                    rule.keyword.clone()
                } else {
                    regex::escape(&rule.keyword)
                };
                // 使用命名捕获组 rN 以便匹配后快速索引颜色
                patterns.push(format!(r"(?P<r{}>{})", i, pat));
                ansi_colors.push(rule.color.to_ansi());
            }

            let combined_re = crate::RegexBuilder::new(&patterns.join("|"))
                .case_insensitive(ignore_case)
                .multi_line(true)
                .dot_matches_new_line(false)
                .build()?;

            Ok(Self {
                regex: combined_re,
                ansi_colors,
            })
        }

        /// Renders a single line of input with highlighting applied.
        ///
        /// Matched segments are wrapped in ANSI color escape sequences.
        /// The output buffer is cleared before writing.
        ///
        /// # Examples
        ///
        /// ```rust
        /// # use highlite::highlight::HighlightingEngine;
        /// # use highlite::rules::{Rule, Color, PresetColor};
        /// let rules = vec![Rule {
        ///     keyword: "OK".into(),
        ///     color: Color::Preset(PresetColor::Green),
        ///     is_regex: false,
        /// }];
        ///
        /// let engine = HighlightingEngine::new(&rules, false).unwrap();
        /// let mut out = String::new();
        ///
        /// engine.render_line("Status: OK\n", &mut out);
        /// assert!(out.contains("\x1b[32mOK\x1b[0m"));
        /// ```
        pub fn render_line(&self, input: &str, output: &mut String) {
            output.clear();
            let mut last_match = 0;

            for caps in self.regex.captures_iter(input) {
                let whole_match = caps.get(0).unwrap();

                // 写入匹配项之前的文本
                output.push_str(&input[last_match..whole_match.start()]);

                // 寻找是哪个规则触发了匹配
                for (i, color_code) in self.ansi_colors.iter().enumerate() {
                    if let Some(m) = caps.name(&format!("r{}", i)) {
                        output.push_str(color_code);
                        output.push_str(m.as_str());
                        output.push_str("\x1b[0m");
                        break;
                    }
                }
                last_match = whole_match.end();
            }
            // 写入剩余文本
            output.push_str(&input[last_match..]);
        }
    }
}
// --- Main Logic ---

/// Executes the main program logic using the provided CLI configuration.
///
/// This function loads the highlighting rules from the configuration file,
/// initializes the highlighting engine, and processes either the specified
/// input file or standard input.
///
/// If no input file is provided, the function reads from `stdin`.
/// When `stdin` is connected to a terminal, an informational message is printed
/// to stderr before waiting for input.
///
/// # Arguments
///
/// * `cli_args` - Parsed command-line arguments controlling input, configuration,
///   and matching behavior.
///
/// # Errors
///
/// Returns an error if:
///
/// * The configuration path is missing
/// * The configuration file cannot be read or parsed
/// * The input file cannot be opened
/// * An I/O error occurs while reading input or writing output
/// * The highlighting engine fails to initialize
///
/// # Examples
///
/// ```no_run
/// use highlite::{run, arg_parser::CliArgs};
///
/// let cli_args = CliArgs {
///     ignore_case: false,
///     file: Some(String::from("path/to/file").into()),
///     config: Some(String::from("path/to/config.yaml").into()),
/// };
///
/// run(cli_args).unwrap();
/// ```
///
/// This function flushes all output before returning.
pub fn run(cli_args: arg_parser::CliArgs) -> anyhow::Result<()> {
    let config_path = cli_args
        .config
        .context("Missing config file. Use --config <PATH>")?;
    let raw_rules = arg_parser::load_rules_from_file(&config_path)?;

    // 1. 预编译引擎
    let engine = highlight::HighlightingEngine::new(&raw_rules, cli_args.ignore_case)?;

    // 2. 准备带缓冲的输出
    let stdout = std::io::stdout();
    let mut writer = BufWriter::new(stdout.lock());

    // 3. 处理输入
    if let Some(path) = cli_args.file {
        let f = fs::File::open(path)?;
        process_stream(BufReader::new(f), &engine, &mut writer)?;
    } else {
        if std::io::stdin().is_terminal() {
            eprintln!("(Info: Waiting for stdin... Press Ctrl+D to end)");
        }
        process_stream(BufReader::new(std::io::stdin()), &engine, &mut writer)?;
    }

    writer.flush()?;
    Ok(())
}

/// Processes a buffered input stream and writes highlighted output.
///
/// This function reads input line by line, applies syntax highlighting,
/// and writes the result to the provided output writer.
///
/// String buffers are reused across iterations to reduce allocations.
///
/// # Errors
///
/// Returns an error if an I/O error occurs while reading or writing.
fn process_stream<R: BufRead, W: Write>(
    mut reader: R,
    engine: &highlight::HighlightingEngine,
    writer: &mut W,
) -> anyhow::Result<()> {
    let mut line_buffer = String::new();
    let mut out_buffer = String::new();

    // 循环复用 String 内存，避免每行都分配内存
    while reader.read_line(&mut line_buffer)? > 0 {
        engine.render_line(&line_buffer, &mut out_buffer);
        writer.write_all(out_buffer.as_bytes())?;
        line_buffer.clear();
    }
    Ok(())
}
